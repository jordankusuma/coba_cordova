{
    "sourceFile": "platforms/android/app/src/main/java/org/apache/cordova/filetransfer/FileTransfer.java",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 4,
            "patches": [
                {
                    "date": 1644387858300,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1644387864627,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -44,8 +44,9 @@\n import org.apache.cordova.CordovaResourceApi.OpenForReadResult;\n import org.apache.cordova.LOG;\n import org.apache.cordova.PluginManager;\n import org.apache.cordova.PluginResult;\n+//import org.apache.cordova.Whitelist;\n import org.apache.cordova.AllowList;\n import org.apache.cordova.file.FileUtils;\n import org.json.JSONArray;\n import org.json.JSONException;\n"
                },
                {
                    "date": 1644387897935,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -681,24 +681,25 @@\n          * Previously the CordovaWebView class had a method, getWhitelist, which would\n          * return a Whitelist object. Since the fixed whitelist is removed in Cordova 4.x,\n          * the correct call now is to shouldAllowRequest from the plugin manager.\n          */\n-        Boolean shouldAllowRequest = null;\n-        if (isLocalTransfer) {\n-            shouldAllowRequest = true;\n-        }\n+        // Boolean shouldAllowRequest = null;\n+        // if (isLocalTransfer) {\n+        //     shouldAllowRequest = true;\n+        // }\n+        // if (shouldAllowRequest == null) {\n+        //     try {\n+        //         Method gwl = webView.getClass().getMethod(\"getWhitelist\");\n+        //         Whitelist whitelist = (Whitelist)gwl.invoke(webView);\n+        //         shouldAllowRequest = whitelist.isUrlWhiteListed(source);\n+        //     } catch (NoSuchMethodException e) {\n+        //     } catch (IllegalAccessException e) {\n+        //     } catch (InvocationTargetException e) {\n+        //     }\n+        // }\n+        \n         if (shouldAllowRequest == null) {\n             try {\n-                Method gwl = webView.getClass().getMethod(\"getWhitelist\");\n-                Whitelist whitelist = (Whitelist)gwl.invoke(webView);\n-                shouldAllowRequest = whitelist.isUrlWhiteListed(source);\n-            } catch (NoSuchMethodException e) {\n-            } catch (IllegalAccessException e) {\n-            } catch (InvocationTargetException e) {\n-            }\n-        }\n-        if (shouldAllowRequest == null) {\n-            try {\n                 Method gpm = webView.getClass().getMethod(\"getPluginManager\");\n                 PluginManager pm = (PluginManager)gpm.invoke(webView);\n                 Method san = pm.getClass().getMethod(\"shouldAllowRequest\", String.class);\n                 shouldAllowRequest = (Boolean)san.invoke(pm, source);\n"
                },
                {
                    "date": 1644387904751,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -695,9 +695,22 @@\n         //     } catch (IllegalAccessException e) {\n         //     } catch (InvocationTargetException e) {\n         //     }\n         // }\n-        \n+        Boolean shouldAllowRequest = null;\n+      if (isLocalTransfer) {\n+          shouldAllowRequest = true;\n+      }\n+      if (shouldAllowRequest == null) {\n+          try {\n+              Method gwl = webView.getClass().getMethod(\"getWhitelist\");\n+              AllowList whitelist = (AllowList)gwl.invoke(webView);\n+              shouldAllowRequest = whitelist.isUrlAllowListed(source);\n+          } catch (NoSuchMethodException e) {\n+          } catch (IllegalAccessException e) {\n+          } catch (InvocationTargetException e) {\n+          }\n+      }\n         if (shouldAllowRequest == null) {\n             try {\n                 Method gpm = webView.getClass().getMethod(\"getPluginManager\");\n                 PluginManager pm = (PluginManager)gpm.invoke(webView);\n"
                },
                {
                    "date": 1644387919470,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -696,23 +696,23 @@\n         //     } catch (InvocationTargetException e) {\n         //     }\n         // }\n         Boolean shouldAllowRequest = null;\n-      if (isLocalTransfer) {\n-          shouldAllowRequest = true;\n-      }\n-      if (shouldAllowRequest == null) {\n-          try {\n-              Method gwl = webView.getClass().getMethod(\"getWhitelist\");\n-              AllowList whitelist = (AllowList)gwl.invoke(webView);\n-              shouldAllowRequest = whitelist.isUrlAllowListed(source);\n-          } catch (NoSuchMethodException e) {\n-          } catch (IllegalAccessException e) {\n-          } catch (InvocationTargetException e) {\n-          }\n-      }\n+        if (isLocalTransfer) {\n+            shouldAllowRequest = true;\n+        }\n         if (shouldAllowRequest == null) {\n             try {\n+                Method gwl = webView.getClass().getMethod(\"getWhitelist\");\n+                AllowList whitelist = (AllowList)gwl.invoke(webView);\n+                shouldAllowRequest = whitelist.isUrlAllowListed(source);\n+            } catch (NoSuchMethodException e) {\n+            } catch (IllegalAccessException e) {\n+            } catch (InvocationTargetException e) {\n+            }\n+        }\n+        if (shouldAllowRequest == null) {\n+            try {\n                 Method gpm = webView.getClass().getMethod(\"getPluginManager\");\n                 PluginManager pm = (PluginManager)gpm.invoke(webView);\n                 Method san = pm.getClass().getMethod(\"shouldAllowRequest\", String.class);\n                 shouldAllowRequest = (Boolean)san.invoke(pm, source);\n"
                }
            ],
            "date": 1644387858300,
            "name": "Commit-0",
            "content": "/*\n       Licensed to the Apache Software Foundation (ASF) under one\n       or more contributor license agreements.  See the NOTICE file\n       distributed with this work for additional information\n       regarding copyright ownership.  The ASF licenses this file\n       to you under the Apache License, Version 2.0 (the\n       \"License\"); you may not use this file except in compliance\n       with the License.  You may obtain a copy of the License at\n\n         http://www.apache.org/licenses/LICENSE-2.0\n\n       Unless required by applicable law or agreed to in writing,\n       software distributed under the License is distributed on an\n       \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n       KIND, either express or implied.  See the License for the\n       specific language governing permissions and limitations\n       under the License.\n*/\npackage org.apache.cordova.filetransfer;\n\nimport java.io.BufferedReader;\nimport java.io.ByteArrayOutputStream;\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FilterInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.net.HttpURLConnection;\nimport java.net.URLConnection;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.Inflater;\n\nimport org.apache.cordova.CallbackContext;\nimport org.apache.cordova.CordovaPlugin;\nimport org.apache.cordova.CordovaResourceApi;\nimport org.apache.cordova.CordovaResourceApi.OpenForReadResult;\nimport org.apache.cordova.LOG;\nimport org.apache.cordova.PluginManager;\nimport org.apache.cordova.PluginResult;\nimport org.apache.cordova.AllowList;\nimport org.apache.cordova.file.FileUtils;\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport android.net.Uri;\nimport android.os.Build;\nimport android.webkit.CookieManager;\n\npublic class FileTransfer extends CordovaPlugin {\n\n    private static final String LOG_TAG = \"FileTransfer\";\n    private static final String LINE_START = \"--\";\n    private static final String LINE_END = \"\\r\\n\";\n    private static final String BOUNDARY =  \"+++++\";\n\n    public static int FILE_NOT_FOUND_ERR = 1;\n    public static int INVALID_URL_ERR = 2;\n    public static int CONNECTION_ERR = 3;\n    public static int ABORTED_ERR = 4;\n    public static int NOT_MODIFIED_ERR = 5;\n\n    private static HashMap<String, RequestContext> activeRequests = new HashMap<String, RequestContext>();\n    private static final int MAX_BUFFER_SIZE = 16 * 1024;\n\n    private static final class RequestContext {\n        String source;\n        String target;\n        File targetFile;\n        CallbackContext callbackContext;\n        HttpURLConnection connection;\n        boolean aborted;\n        RequestContext(String source, String target, CallbackContext callbackContext) {\n            this.source = source;\n            this.target = target;\n            this.callbackContext = callbackContext;\n        }\n        void sendPluginResult(PluginResult pluginResult) {\n            synchronized (this) {\n                if (!aborted) {\n                    callbackContext.sendPluginResult(pluginResult);\n                }\n            }\n        }\n    }\n\n    /**\n     * Adds an interface method to an InputStream to return the number of bytes\n     * read from the raw stream. This is used to track total progress against\n     * the HTTP Content-Length header value from the server.\n     */\n    private static abstract class TrackingInputStream extends FilterInputStream {\n      public TrackingInputStream(final InputStream in) {\n        super(in);\n      }\n        public abstract long getTotalRawBytesRead();\n  }\n\n    private static class ExposedGZIPInputStream extends GZIPInputStream {\n      public ExposedGZIPInputStream(final InputStream in) throws IOException {\n        super(in);\n      }\n      public Inflater getInflater() {\n        return inf;\n      }\n  }\n\n    /**\n     * Provides raw bytes-read tracking for a GZIP input stream. Reports the\n     * total number of compressed bytes read from the input, rather than the\n     * number of uncompressed bytes.\n     */\n    private static class TrackingGZIPInputStream extends TrackingInputStream {\n      private ExposedGZIPInputStream gzin;\n      public TrackingGZIPInputStream(final ExposedGZIPInputStream gzin) throws IOException {\n        super(gzin);\n        this.gzin = gzin;\n      }\n      public long getTotalRawBytesRead() {\n        return gzin.getInflater().getBytesRead();\n      }\n  }\n\n    /**\n     * Provides simple total-bytes-read tracking for an existing InputStream\n     */\n    private static class SimpleTrackingInputStream extends TrackingInputStream {\n        private long bytesRead = 0;\n        public SimpleTrackingInputStream(InputStream stream) {\n            super(stream);\n        }\n\n        private int updateBytesRead(int newBytesRead) {\n          if (newBytesRead != -1) {\n            bytesRead += newBytesRead;\n          }\n          return newBytesRead;\n        }\n\n        @Override\n        public int read() throws IOException {\n            return updateBytesRead(super.read());\n        }\n\n        // Note: FilterInputStream delegates read(byte[] bytes) to the below method,\n        // so we don't override it or else double count (CB-5631).\n        @Override\n        public int read(byte[] bytes, int offset, int count) throws IOException {\n            return updateBytesRead(super.read(bytes, offset, count));\n        }\n\n        public long getTotalRawBytesRead() {\n          return bytesRead;\n        }\n    }\n\n    @Override\n    public boolean execute(String action, JSONArray args, final CallbackContext callbackContext) throws JSONException {\n        if (action.equals(\"upload\") || action.equals(\"download\")) {\n            String source = args.getString(0);\n            String target = args.getString(1);\n\n            if (action.equals(\"upload\")) {\n                upload(source, target, args, callbackContext);\n            } else {\n                download(source, target, args, callbackContext);\n            }\n            return true;\n        } else if (action.equals(\"abort\")) {\n            String objectId = args.getString(0);\n            abort(objectId);\n            callbackContext.success();\n            return true;\n        }\n        return false;\n    }\n\n    private static void addHeadersToRequest(URLConnection connection, JSONObject headers) {\n        try {\n            for (Iterator<?> iter = headers.keys(); iter.hasNext(); ) {\n                /* RFC 2616 says that non-ASCII characters and control\n                 * characters are not allowed in header names or values.\n                 * Additionally, spaces are not allowed in header names.\n                 * RFC 2046 Quoted-printable encoding may be used to encode\n                 * arbitrary characters, but we donon- not do that encoding here.\n                 */\n                String headerKey = iter.next().toString();\n                String cleanHeaderKey = headerKey.replaceAll(\"\\\\n\",\"\")\n                        .replaceAll(\"\\\\s+\",\"\")\n                        .replaceAll(\":\", \"\")\n                        .replaceAll(\"[^\\\\x20-\\\\x7E]+\", \"\");\n\n                JSONArray headerValues = headers.optJSONArray(headerKey);\n                if (headerValues == null) {\n                    headerValues = new JSONArray();\n\n                     /* RFC 2616 also says that any amount of consecutive linear\n                      * whitespace within a header value can be replaced with a\n                      * single space character, without affecting the meaning of\n                      * that value.\n                      */\n\n                    String headerValue = headers.getString(headerKey);\n                    String finalValue = headerValue.replaceAll(\"\\\\s+\", \" \").replaceAll(\"\\\\n\",\" \").replaceAll(\"[^\\\\x20-\\\\x7E]+\", \" \");\n                    headerValues.put(finalValue);\n                }\n\n                //Use the clean header key, not the one that we passed in\n                connection.setRequestProperty(cleanHeaderKey, headerValues.getString(0));\n                for (int i = 1; i < headerValues.length(); ++i) {\n                    connection.addRequestProperty(headerKey, headerValues.getString(i));\n                }\n            }\n        } catch (JSONException e1) {\n          // No headers to be manipulated!\n        }\n    }\n\n    private String getCookies(final String target) {\n        boolean gotCookie = false;\n        String cookie = null;\n        Class webViewClass = webView.getClass();\n        try {\n            Method gcmMethod = webViewClass.getMethod(\"getCookieManager\");\n            Class iccmClass  = gcmMethod.getReturnType();\n            Method gcMethod  = iccmClass.getMethod(\"getCookie\", String.class);\n\n            cookie = (String)gcMethod.invoke(\n                        iccmClass.cast(\n                            gcmMethod.invoke(webView)\n                        ), target);\n\n            gotCookie = true;\n        } catch (NoSuchMethodException e) {\n        } catch (IllegalAccessException e) {\n        } catch (InvocationTargetException e) {\n        } catch (ClassCastException e) {\n        }\n\n        if (!gotCookie && CookieManager.getInstance() != null) {\n            cookie = CookieManager.getInstance().getCookie(target);\n        }\n\n        return cookie;\n    }\n\n    /**\n     * Uploads the specified file to the server URL provided using an HTTP multipart request.\n     * @param source        Full path of the file on the file system\n     * @param target        URL of the server to receive the file\n     * @param args          JSON Array of args\n     * @param callbackContext    callback id for optional progress reports\n     *\n     * args[2] fileKey       Name of file request parameter\n     * args[3] fileName      File name to be used on server\n     * args[4] mimeType      Describes file content type\n     * args[5] params        key:value pairs of user-defined parameters\n     * @return FileUploadResult containing result of upload request\n     */\n    private void upload(final String source, final String target, JSONArray args, CallbackContext callbackContext) throws JSONException {\n        LOG.d(LOG_TAG, \"upload \" + source + \" to \" +  target);\n\n        // Setup the options\n        final String fileKey = getArgument(args, 2, \"file\");\n        final String fileName = getArgument(args, 3, \"image.jpg\");\n        final String mimeType = getArgument(args, 4, \"image/jpeg\");\n        final JSONObject params = args.optJSONObject(5) == null ? new JSONObject() : args.optJSONObject(5);\n        // Always use chunked mode unless set to false as per API\n        final boolean chunkedMode = args.optBoolean(7) || args.isNull(7);\n        // Look for headers on the params map for backwards compatibility with older Cordova versions.\n        final JSONObject headers = args.optJSONObject(8) == null ? params.optJSONObject(\"headers\") : args.optJSONObject(8);\n        final String objectId = args.getString(9);\n        final String httpMethod = getArgument(args, 10, \"POST\");\n\n        final CordovaResourceApi resourceApi = webView.getResourceApi();\n\n        LOG.d(LOG_TAG, \"fileKey: \" + fileKey);\n        LOG.d(LOG_TAG, \"fileName: \" + fileName);\n        LOG.d(LOG_TAG, \"mimeType: \" + mimeType);\n        LOG.d(LOG_TAG, \"params: \" + params);\n        LOG.d(LOG_TAG, \"chunkedMode: \" + chunkedMode);\n        LOG.d(LOG_TAG, \"headers: \" + headers);\n        LOG.d(LOG_TAG, \"objectId: \" + objectId);\n        LOG.d(LOG_TAG, \"httpMethod: \" + httpMethod);\n\n        final Uri targetUri = resourceApi.remapUri(Uri.parse(target));\n\n        int uriType = CordovaResourceApi.getUriType(targetUri);\n        final boolean useHttps = uriType == CordovaResourceApi.URI_TYPE_HTTPS;\n        if (uriType != CordovaResourceApi.URI_TYPE_HTTP && !useHttps) {\n            JSONObject error = createFileTransferError(INVALID_URL_ERR, source, target, null, 0, null);\n            LOG.e(LOG_TAG, \"Unsupported URI: \" + targetUri);\n            callbackContext.sendPluginResult(new PluginResult(PluginResult.Status.IO_EXCEPTION, error));\n            return;\n        }\n\n        final RequestContext context = new RequestContext(source, target, callbackContext);\n        synchronized (activeRequests) {\n            activeRequests.put(objectId, context);\n        }\n\n        cordova.getThreadPool().execute(new Runnable() {\n            public void run() {\n                if (context.aborted) {\n                    return;\n                }\n\n                // We should call remapUri on background thread otherwise it throws\n                // IllegalStateException when trying to remap 'cdvfile://localhost/content/...' URIs\n                // via ContentFilesystem (see https://issues.apache.org/jira/browse/CB-9022)\n                Uri tmpSrc = Uri.parse(source);\n                final Uri sourceUri = resourceApi.remapUri(\n                        tmpSrc.getScheme() != null ? tmpSrc : Uri.fromFile(new File(source)));\n\n                HttpURLConnection conn = null;\n                int totalBytes = 0;\n                int fixedLength = -1;\n                try {\n                    // Create return object\n                    FileUploadResult result = new FileUploadResult();\n                    FileProgressResult progress = new FileProgressResult();\n\n                    //------------------ CLIENT REQUEST\n                    // Open a HTTP connection to the URL based on protocol\n                    conn = resourceApi.createHttpConnection(targetUri);\n\n                    // Allow Inputs\n                    conn.setDoInput(true);\n\n                    // Allow Outputs\n                    conn.setDoOutput(true);\n\n                    // Don't use a cached copy.\n                    conn.setUseCaches(false);\n\n                    // Use a post method.\n                    conn.setRequestMethod(httpMethod);\n\n                    // if we specified a Content-Type header, don't do multipart form upload\n                    boolean multipartFormUpload = (headers == null) || !headers.has(\"Content-Type\");\n                    if (multipartFormUpload) {\n                        conn.setRequestProperty(\"Content-Type\", \"multipart/form-data; boundary=\" + BOUNDARY);\n                    }\n\n                    // Set the cookies on the response\n                    String cookie = getCookies(target);\n\n                    if (cookie != null) {\n                        conn.setRequestProperty(\"Cookie\", cookie);\n                    }\n\n                    // Handle the other headers\n                    if (headers != null) {\n                        addHeadersToRequest(conn, headers);\n                    }\n\n                    /*\n                        * Store the non-file portions of the multipart data as a string, so that we can add it\n                        * to the contentSize, since it is part of the body of the HTTP request.\n                        */\n                    StringBuilder beforeData = new StringBuilder();\n                    try {\n                        for (Iterator<?> iter = params.keys(); iter.hasNext();) {\n                            Object key = iter.next();\n                            if(!String.valueOf(key).equals(\"headers\"))\n                            {\n                              beforeData.append(LINE_START).append(BOUNDARY).append(LINE_END);\n                              beforeData.append(\"Content-Disposition: form-data; name=\\\"\").append(key.toString()).append('\"');\n                              beforeData.append(LINE_END).append(LINE_END);\n                              beforeData.append(params.getString(key.toString()));\n                              beforeData.append(LINE_END);\n                            }\n                        }\n                    } catch (JSONException e) {\n                        LOG.e(LOG_TAG, e.getMessage(), e);\n                    }\n\n                    beforeData.append(LINE_START).append(BOUNDARY).append(LINE_END);\n                    beforeData.append(\"Content-Disposition: form-data; name=\\\"\").append(fileKey).append(\"\\\";\");\n                    beforeData.append(\" filename=\\\"\").append(fileName).append('\"').append(LINE_END);\n                    beforeData.append(\"Content-Type: \").append(mimeType).append(LINE_END).append(LINE_END);\n                    byte[] beforeDataBytes = beforeData.toString().getBytes(\"UTF-8\");\n                    byte[] tailParamsBytes = (LINE_END + LINE_START + BOUNDARY + LINE_START + LINE_END).getBytes(\"UTF-8\");\n\n\n                    // Get a input stream of the file on the phone\n                    OpenForReadResult readResult = resourceApi.openForRead(sourceUri);\n\n                    int stringLength = beforeDataBytes.length + tailParamsBytes.length;\n                    if (readResult.length >= 0) {\n                        fixedLength = (int)readResult.length;\n                        if (multipartFormUpload)\n                            fixedLength += stringLength;\n                        progress.setLengthComputable(true);\n                        progress.setTotal(fixedLength);\n                    }\n                    LOG.d(LOG_TAG, \"Content Length: \" + fixedLength);\n                    // setFixedLengthStreamingMode causes and OutOfMemoryException on pre-Froyo devices.\n                    // http://code.google.com/p/android/issues/detail?id=3164\n                    // It also causes OOM if HTTPS is used, even on newer devices.\n                    boolean useChunkedMode = chunkedMode || (Build.VERSION.SDK_INT < Build.VERSION_CODES.FROYO);\n                    useChunkedMode = useChunkedMode || (fixedLength == -1);\n\n                    if (useChunkedMode) {\n                        conn.setChunkedStreamingMode(MAX_BUFFER_SIZE);\n                        // Although setChunkedStreamingMode sets this header, setting it explicitly here works\n                        // around an OutOfMemoryException when using https.\n                        conn.setRequestProperty(\"Transfer-Encoding\", \"chunked\");\n                    } else {\n                        conn.setFixedLengthStreamingMode(fixedLength);\n\n                        if (useHttps) {\n                            LOG.w(LOG_TAG, \"setFixedLengthStreamingMode could cause OutOfMemoryException - switch to chunkedMode=true to avoid it if this is an issue.\");\n                        }\n                    }\n\n                    conn.connect();\n\n                    OutputStream sendStream = null;\n                    try {\n                        sendStream = conn.getOutputStream();\n                        synchronized (context) {\n                            if (context.aborted) {\n                                return;\n                            }\n                            context.connection = conn;\n                        }\n\n                        if (multipartFormUpload) {\n                            //We don't want to change encoding, we just want this to write for all Unicode.\n                            sendStream.write(beforeDataBytes);\n                            totalBytes += beforeDataBytes.length;\n                        }\n\n                        // create a buffer of maximum size\n                        int bytesAvailable = readResult.inputStream.available();\n                        int bufferSize = Math.min(bytesAvailable, MAX_BUFFER_SIZE);\n                        byte[] buffer = new byte[bufferSize];\n\n                        // read file and write it into form...\n                        int bytesRead = readResult.inputStream.read(buffer, 0, bufferSize);\n\n                        long prevBytesRead = 0;\n                        while (bytesRead > 0) {\n                            totalBytes += bytesRead;\n                            result.setBytesSent(totalBytes);\n                            sendStream.write(buffer, 0, bytesRead);\n                            if (totalBytes > prevBytesRead + 102400) {\n                                prevBytesRead = totalBytes;\n                                LOG.d(LOG_TAG, \"Uploaded \" + totalBytes + \" of \" + fixedLength + \" bytes\");\n                            }\n                            bytesAvailable = readResult.inputStream.available();\n                            bufferSize = Math.min(bytesAvailable, MAX_BUFFER_SIZE);\n                            bytesRead = readResult.inputStream.read(buffer, 0, bufferSize);\n\n                            // Send a progress event.\n                            progress.setLoaded(totalBytes);\n                            PluginResult progressResult = new PluginResult(PluginResult.Status.OK, progress.toJSONObject());\n                            progressResult.setKeepCallback(true);\n                            context.sendPluginResult(progressResult);\n                        }\n\n                        if (multipartFormUpload) {\n                            // send multipart form data necessary after file data...\n                            sendStream.write(tailParamsBytes);\n                            totalBytes += tailParamsBytes.length;\n                        }\n                        sendStream.flush();\n                    } finally {\n                        safeClose(readResult.inputStream);\n                        safeClose(sendStream);\n                    }\n                    synchronized (context) {\n                        context.connection = null;\n                    }\n                    LOG.d(LOG_TAG, \"Sent \" + totalBytes + \" of \" + fixedLength);\n\n                    //------------------ read the SERVER RESPONSE\n                    String responseString;\n                    int responseCode = conn.getResponseCode();\n                    LOG.d(LOG_TAG, \"response code: \" + responseCode);\n                    LOG.d(LOG_TAG, \"response headers: \" + conn.getHeaderFields());\n                    TrackingInputStream inStream = null;\n                    try {\n                        inStream = getInputStream(conn);\n                        synchronized (context) {\n                            if (context.aborted) {\n                                return;\n                            }\n                            context.connection = conn;\n                        }\n\n                        ByteArrayOutputStream out = new ByteArrayOutputStream(Math.max(1024, conn.getContentLength()));\n                        byte[] buffer = new byte[1024];\n                        int bytesRead = 0;\n                        // write bytes to file\n                        while ((bytesRead = inStream.read(buffer)) > 0) {\n                            out.write(buffer, 0, bytesRead);\n                        }\n                        responseString = out.toString(\"UTF-8\");\n                    } finally {\n                        synchronized (context) {\n                            context.connection = null;\n                        }\n                        safeClose(inStream);\n                    }\n\n                    LOG.d(LOG_TAG, \"got response from server\");\n                    LOG.d(LOG_TAG, responseString.substring(0, Math.min(256, responseString.length())));\n\n                    // send request and retrieve response\n                    result.setResponseCode(responseCode);\n                    result.setResponse(responseString);\n\n                    context.sendPluginResult(new PluginResult(PluginResult.Status.OK, result.toJSONObject()));\n                } catch (FileNotFoundException e) {\n                    JSONObject error = createFileTransferError(FILE_NOT_FOUND_ERR, source, target, conn, e);\n                    LOG.e(LOG_TAG, error.toString(), e);\n                    context.sendPluginResult(new PluginResult(PluginResult.Status.IO_EXCEPTION, error));\n                } catch (IOException e) {\n                    JSONObject error = createFileTransferError(CONNECTION_ERR, source, target, conn, e);\n                    LOG.e(LOG_TAG, error.toString(), e);\n                    LOG.e(LOG_TAG, \"Failed after uploading \" + totalBytes + \" of \" + fixedLength + \" bytes.\");\n                    context.sendPluginResult(new PluginResult(PluginResult.Status.IO_EXCEPTION, error));\n                } catch (JSONException e) {\n                    LOG.e(LOG_TAG, e.getMessage(), e);\n                    context.sendPluginResult(new PluginResult(PluginResult.Status.JSON_EXCEPTION));\n                } catch (Throwable t) {\n                    // Shouldn't happen, but will\n                    JSONObject error = createFileTransferError(CONNECTION_ERR, source, target, conn, t);\n                    LOG.e(LOG_TAG, error.toString(), t);\n                    context.sendPluginResult(new PluginResult(PluginResult.Status.IO_EXCEPTION, error));\n                } finally {\n                    synchronized (activeRequests) {\n                        activeRequests.remove(objectId);\n                    }\n                }\n            }\n        });\n    }\n\n    private static void safeClose(Closeable stream) {\n        if (stream != null) {\n            try {\n                stream.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n\n    private static TrackingInputStream getInputStream(URLConnection conn) throws IOException {\n        String encoding = conn.getContentEncoding();\n        if (encoding != null && encoding.equalsIgnoreCase(\"gzip\")) {\n          return new TrackingGZIPInputStream(new ExposedGZIPInputStream(conn.getInputStream()));\n        }\n        return new SimpleTrackingInputStream(conn.getInputStream());\n    }\n\n    private static JSONObject createFileTransferError(int errorCode, String source, String target, URLConnection connection, Throwable throwable) {\n\n        int httpStatus = 0;\n        StringBuilder bodyBuilder = new StringBuilder();\n        String body = null;\n        if (connection != null) {\n            try {\n                if (connection instanceof HttpURLConnection) {\n                    httpStatus = ((HttpURLConnection)connection).getResponseCode();\n                    InputStream err = ((HttpURLConnection) connection).getErrorStream();\n                    if(err != null)\n                    {\n                        BufferedReader reader = new BufferedReader(new InputStreamReader(err, \"UTF-8\"));\n                        try {\n                            String line = reader.readLine();\n                            while(line != null) {\n                                bodyBuilder.append(line);\n                                line = reader.readLine();\n                                if(line != null) {\n                                    bodyBuilder.append('\\n');\n                                }\n                            }\n                            body = bodyBuilder.toString();\n                        } finally {\n                            reader.close();\n                        }\n                    }\n                }\n            // IOException can leave connection object in a bad state, so catch all exceptions.\n            } catch (Throwable e) {\n                LOG.w(LOG_TAG, \"Error getting HTTP status code from connection.\", e);\n            }\n        }\n\n        return createFileTransferError(errorCode, source, target, body, httpStatus, throwable);\n    }\n\n        /**\n        * Create an error object based on the passed in errorCode\n        * @param errorCode      the error\n        * @return JSONObject containing the error\n        */\n    private static JSONObject createFileTransferError(int errorCode, String source, String target, String body, Integer httpStatus, Throwable throwable) {\n        JSONObject error = null;\n        try {\n            error = new JSONObject();\n            error.put(\"code\", errorCode);\n            error.put(\"source\", source);\n            error.put(\"target\", target);\n            if(body != null)\n            {\n                error.put(\"body\", body);\n            }\n            if (httpStatus != null) {\n                error.put(\"http_status\", httpStatus);\n            }\n            if (throwable != null) {\n                String msg = throwable.getMessage();\n                if (msg == null || \"\".equals(msg)) {\n                    msg = throwable.toString();\n                }\n                error.put(\"exception\", msg);\n            }\n        } catch (JSONException e) {\n            LOG.e(LOG_TAG, e.getMessage(), e);\n        }\n        return error;\n    }\n\n    /**\n     * Convenience method to read a parameter from the list of JSON args.\n     * @param args                      the args passed to the Plugin\n     * @param position          the position to retrieve the arg from\n     * @param defaultString the default to be used if the arg does not exist\n     * @return String with the retrieved value\n     */\n    private static String getArgument(JSONArray args, int position, String defaultString) {\n        String arg = defaultString;\n        if (args.length() > position) {\n            arg = args.optString(position);\n            if (arg == null || \"null\".equals(arg)) {\n                arg = defaultString;\n            }\n        }\n        return arg;\n    }\n\n    /**\n     * Downloads a file form a given URL and saves it to the specified directory.\n     *\n     * @param source        URL of the server to receive the file\n     * @param target            Full path of the file on the file system\n     */\n    private void download(final String source, final String target, JSONArray args, CallbackContext callbackContext) throws JSONException {\n        LOG.d(LOG_TAG, \"download \" + source + \" to \" +  target);\n\n        final CordovaResourceApi resourceApi = webView.getResourceApi();\n\n        final String objectId = args.getString(3);\n        final JSONObject headers = args.optJSONObject(4);\n\n        final Uri sourceUri = resourceApi.remapUri(Uri.parse(source));\n        int uriType = CordovaResourceApi.getUriType(sourceUri);\n        final boolean useHttps = uriType == CordovaResourceApi.URI_TYPE_HTTPS;\n        final boolean isLocalTransfer = !useHttps && uriType != CordovaResourceApi.URI_TYPE_HTTP;\n        if (uriType == CordovaResourceApi.URI_TYPE_UNKNOWN) {\n            JSONObject error = createFileTransferError(INVALID_URL_ERR, source, target, null, 0, null);\n            LOG.e(LOG_TAG, \"Unsupported URI: \" + sourceUri);\n            callbackContext.sendPluginResult(new PluginResult(PluginResult.Status.IO_EXCEPTION, error));\n            return;\n        }\n\n        /* This code exists for compatibility between 3.x and 4.x versions of Cordova.\n         * Previously the CordovaWebView class had a method, getWhitelist, which would\n         * return a Whitelist object. Since the fixed whitelist is removed in Cordova 4.x,\n         * the correct call now is to shouldAllowRequest from the plugin manager.\n         */\n        Boolean shouldAllowRequest = null;\n        if (isLocalTransfer) {\n            shouldAllowRequest = true;\n        }\n        if (shouldAllowRequest == null) {\n            try {\n                Method gwl = webView.getClass().getMethod(\"getWhitelist\");\n                Whitelist whitelist = (Whitelist)gwl.invoke(webView);\n                shouldAllowRequest = whitelist.isUrlWhiteListed(source);\n            } catch (NoSuchMethodException e) {\n            } catch (IllegalAccessException e) {\n            } catch (InvocationTargetException e) {\n            }\n        }\n        if (shouldAllowRequest == null) {\n            try {\n                Method gpm = webView.getClass().getMethod(\"getPluginManager\");\n                PluginManager pm = (PluginManager)gpm.invoke(webView);\n                Method san = pm.getClass().getMethod(\"shouldAllowRequest\", String.class);\n                shouldAllowRequest = (Boolean)san.invoke(pm, source);\n            } catch (NoSuchMethodException e) {\n            } catch (IllegalAccessException e) {\n            } catch (InvocationTargetException e) {\n            }\n        }\n\n        if (!Boolean.TRUE.equals(shouldAllowRequest)) {\n            LOG.w(LOG_TAG, \"Source URL is not in white list: '\" + source + \"'\");\n            JSONObject error = createFileTransferError(CONNECTION_ERR, source, target, null, 401, null);\n            callbackContext.sendPluginResult(new PluginResult(PluginResult.Status.IO_EXCEPTION, error));\n            return;\n        }\n\n\n        final RequestContext context = new RequestContext(source, target, callbackContext);\n        synchronized (activeRequests) {\n            activeRequests.put(objectId, context);\n        }\n\n        cordova.getThreadPool().execute(new Runnable() {\n            public void run() {\n                if (context.aborted) {\n                    return;\n                }\n\n                // Accept a path or a URI for the source.\n                Uri tmpTarget = Uri.parse(target);\n                Uri targetUri = resourceApi.remapUri(\n                        tmpTarget.getScheme() != null ? tmpTarget : Uri.fromFile(new File(target)));\n                HttpURLConnection connection = null;\n                File file = null;\n                PluginResult result = null;\n                TrackingInputStream inputStream = null;\n                boolean cached = false;\n\n                OutputStream outputStream = null;\n                try {\n                    OpenForReadResult readResult = null;\n\n                    file = resourceApi.mapUriToFile(targetUri);\n                    context.targetFile = file;\n\n                    LOG.d(LOG_TAG, \"Download file:\" + sourceUri);\n\n                    FileProgressResult progress = new FileProgressResult();\n\n                    if (isLocalTransfer) {\n                        readResult = resourceApi.openForRead(sourceUri);\n                        if (readResult.length != -1) {\n                            progress.setLengthComputable(true);\n                            progress.setTotal(readResult.length);\n                        }\n                        inputStream = new SimpleTrackingInputStream(readResult.inputStream);\n                    } else {\n                        // connect to server\n                        // Open a HTTP connection to the URL based on protocol\n                        connection = resourceApi.createHttpConnection(sourceUri);\n                        connection.setRequestMethod(\"GET\");\n\n                        // TODO: Make OkHttp use this CookieManager by default.\n                        String cookie = getCookies(sourceUri.toString());\n\n                        if(cookie != null)\n                        {\n                            connection.setRequestProperty(\"cookie\", cookie);\n                        }\n\n                        // This must be explicitly set for gzip progress tracking to work.\n                        connection.setRequestProperty(\"Accept-Encoding\", \"gzip\");\n\n                        // Handle the other headers\n                        if (headers != null) {\n                            addHeadersToRequest(connection, headers);\n                        }\n\n                        connection.connect();\n                        if (connection.getResponseCode() == HttpURLConnection.HTTP_NOT_MODIFIED) {\n                            cached = true;\n                            connection.disconnect();\n                            LOG.d(LOG_TAG, \"Resource not modified: \" + source);\n                            JSONObject error = createFileTransferError(NOT_MODIFIED_ERR, source, target, connection, null);\n                            result = new PluginResult(PluginResult.Status.ERROR, error);\n                        } else {\n                            if (connection.getContentEncoding() == null || connection.getContentEncoding().equalsIgnoreCase(\"gzip\")) {\n                                // Only trust content-length header if we understand\n                                // the encoding -- identity or gzip\n                                if (connection.getContentLength() != -1) {\n                                    progress.setLengthComputable(true);\n                                    progress.setTotal(connection.getContentLength());\n                                }\n                            }\n                            inputStream = getInputStream(connection);\n                        }\n                    }\n\n                    if (!cached) {\n                        try {\n                            synchronized (context) {\n                                if (context.aborted) {\n                                    return;\n                                }\n                                context.connection = connection;\n                            }\n\n                            // write bytes to file\n                            byte[] buffer = new byte[MAX_BUFFER_SIZE];\n                            int bytesRead = 0;\n                            outputStream = resourceApi.openOutputStream(targetUri);\n                            while ((bytesRead = inputStream.read(buffer)) > 0) {\n                                outputStream.write(buffer, 0, bytesRead);\n                                // Send a progress event.\n                                progress.setLoaded(inputStream.getTotalRawBytesRead());\n                                PluginResult progressResult = new PluginResult(PluginResult.Status.OK, progress.toJSONObject());\n                                progressResult.setKeepCallback(true);\n                                context.sendPluginResult(progressResult);\n                            }\n                        } finally {\n                            synchronized (context) {\n                                context.connection = null;\n                            }\n                            safeClose(inputStream);\n                            safeClose(outputStream);\n                        }\n\n                        LOG.d(LOG_TAG, \"Saved file: \" + target);\n\n\n                        // create FileEntry object\n                        Class webViewClass = webView.getClass();\n                        PluginManager pm = null;\n                        try {\n                            Method gpm = webViewClass.getMethod(\"getPluginManager\");\n                            pm = (PluginManager) gpm.invoke(webView);\n                        } catch (NoSuchMethodException e) {\n                        } catch (IllegalAccessException e) {\n                        } catch (InvocationTargetException e) {\n                        }\n                        if (pm == null) {\n                            try {\n                                Field pmf = webViewClass.getField(\"pluginManager\");\n                                pm = (PluginManager)pmf.get(webView);\n                            } catch (NoSuchFieldException e) {\n                            } catch (IllegalAccessException e) {\n                            }\n                        }\n                        file = resourceApi.mapUriToFile(targetUri);\n                        context.targetFile = file;\n                        FileUtils filePlugin = (FileUtils) pm.getPlugin(\"File\");\n                        if (filePlugin != null) {\n                            JSONObject fileEntry = filePlugin.getEntryForFile(file);\n                            if (fileEntry != null) {\n                                result = new PluginResult(PluginResult.Status.OK, fileEntry);\n                            } else {\n                                JSONObject error = createFileTransferError(CONNECTION_ERR, source, target, connection, null);\n                                LOG.e(LOG_TAG, \"File plugin cannot represent download path\");\n                                result = new PluginResult(PluginResult.Status.IO_EXCEPTION, error);\n                            }\n                        } else {\n                            LOG.e(LOG_TAG, \"File plugin not found; cannot save downloaded file\");\n                            result = new PluginResult(PluginResult.Status.ERROR, \"File plugin not found; cannot save downloaded file\");\n                        }\n                    }\n                } catch (FileNotFoundException e) {\n                    JSONObject error = createFileTransferError(FILE_NOT_FOUND_ERR, source, target, connection, e);\n                    LOG.e(LOG_TAG, error.toString(), e);\n                    result = new PluginResult(PluginResult.Status.IO_EXCEPTION, error);\n                } catch (IOException e) {\n                    JSONObject error = createFileTransferError(CONNECTION_ERR, source, target, connection, e);\n                    LOG.e(LOG_TAG, error.toString(), e);\n                    result = new PluginResult(PluginResult.Status.IO_EXCEPTION, error);\n                } catch (JSONException e) {\n                    LOG.e(LOG_TAG, e.getMessage(), e);\n                    result = new PluginResult(PluginResult.Status.JSON_EXCEPTION);\n                } catch (Throwable e) {\n                    JSONObject error = createFileTransferError(CONNECTION_ERR, source, target, connection, e);\n                    LOG.e(LOG_TAG, error.toString(), e);\n                    result = new PluginResult(PluginResult.Status.IO_EXCEPTION, error);\n                } finally {\n                    synchronized (activeRequests) {\n                        activeRequests.remove(objectId);\n                    }\n\n                    if (result == null) {\n                        result = new PluginResult(PluginResult.Status.ERROR, createFileTransferError(CONNECTION_ERR, source, target, connection, null));\n                    }\n                    // Remove incomplete download.\n                    if (!cached && result.getStatus() != PluginResult.Status.OK.ordinal() && file != null) {\n                        file.delete();\n                    }\n                    context.sendPluginResult(result);\n                }\n            }\n        });\n    }\n\n    /**\n     * Abort an ongoing upload or download.\n     */\n    private void abort(String objectId) {\n        final RequestContext context;\n        synchronized (activeRequests) {\n            context = activeRequests.remove(objectId);\n        }\n        if (context != null) {\n            // Closing the streams can block, so execute on a background thread.\n            cordova.getThreadPool().execute(new Runnable() {\n                public void run() {\n                    synchronized (context) {\n                        File file = context.targetFile;\n                        if (file != null) {\n                            file.delete();\n                        }\n                        // Trigger the abort callback immediately to minimize latency between it and abort() being called.\n                        JSONObject error = createFileTransferError(ABORTED_ERR, context.source, context.target, null, -1, null);\n                        context.sendPluginResult(new PluginResult(PluginResult.Status.ERROR, error));\n                        context.aborted = true;\n                        if (context.connection != null) {\n                            try {\n                                context.connection.disconnect();\n                            } catch (Exception e) {\n                                LOG.e(LOG_TAG, \"CB-8431 Catch workaround for fatal exception\", e);\n                            }\n                        }\n                    }\n                }\n            });\n        }\n    }\n}\n"
        }
    ]
}